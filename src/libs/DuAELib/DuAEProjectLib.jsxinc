/**
 * After Effects project methods
 * @namespace
 * @memberof DuAEF.DuAE
 */
DuAEF.DuAE.Project = {};

//undocumented flags
DuAEF.DuAE.Project.progressMode = false;
DuAEF.DuAE.Project.activeComp = null;
DuAEF.DuAE.Project.progressComp = null;
DuAEF.DuAE.Project.viewerMaximized = false;

//caches
//this must be set to true during work on the cache to prevent it from updating
DuAEF.DuAE.Project.suspendCacheUpdates = false;

// the expression cache is an array of PropertyExpression
DuAEF.DuAE.Project.expressionCache = [];
DuAEF.DuAE.Project.lastExpressionCacheUpdateTime = 0;

/**
 * Sets the project in "waiting mode" to speed up things.
 * @param {bool} [inProgress=true] - True to set progress mode, false to stop it.
 */
DuAEF.DuAE.Project.setProgressMode = function ( inProgress ) {
    inProgress = def (inProgress, true);
    if ( !inProgress && !DuAEF.DuAE.Project.progressMode ) return;

    if ( inProgress ) {

        //if not already in progress, create temp comp etc
        if (!DuAEF.DuAE.Project.progressMode || !Object.isValid(DuAEF.DuAE.Project.progressComp))
        {
            //store the current comp
            DuAEF.DuAE.Project.activeComp = DuAEF.DuAE.Project.getActiveComp();

            if ( app.activeViewer != null ) DuAEF.DuAE.Project.viewerMaximized = app.activeViewer.maximized;

            //create a temp comp, open it
            DuAEF.DuAE.Project.progressComp = app.project.items.addComp( "MAGIC IS HAPPENING...", 500, 500, 1, 1, 1 );

            var tempL = DuAEF.DuAE.Project.progressComp.layers.addShape();
            tempL.applyPreset( DuAEF.DuAE.Presets.MAGIC );
            tempL.selected = false;
        }

        //open and maximize the temp comp
        DuAEF.DuAE.Project.progressComp.openInViewer();
        if ( app.activeViewer != null ) app.activeViewer.maximized = true;

        DuAEF.DuAE.Project.progressMode = true;
    } else {
        //remove temp comp
        if ( DuAEF.DuAE.Project.progressComp != null ) DuAEF.DuAE.Project.progressComp.remove();
        //re-activate previous comp
        if ( DuAEF.DuAE.Project.activeComp != null ) DuAEF.DuAE.Project.activeComp.openInViewer();
        if ( app.activeViewer != null ) app.activeViewer.maximized = DuAEF.DuAE.Project.viewerMaximized;

        DuAEF.DuAE.Project.progressMode = false;
    }

}

/**
 * Gets all compositions in the project (or only the root of the project, ignoring subfolders)
 * @param {boolean} [rootOnly=false] Set to true to get only comps from the root of the project
 * @return {CompItem[]} The compositions
 */
DuAEF.DuAE.Project.getComps = function ( rootOnly ) {
    rootOnly = def( rootOnly, false );
    var comps = [];
    var it = new Iterator( app.project.items );
    it.do( function ( comp ) {
        if ( comp instanceof CompItem ) {
            if ( rootOnly && comp.parentFolder != app.project.rootFolder ) return;
            comps.push( comp );
        }
    } );
    return comps;
}

/**
 * Gets the After Effects current composition
 * @return {CompItem|null} The current composition or null if there's no current comp
 */
DuAEF.DuAE.Project.getActiveComp = function () {
    if ( DuAEF.DuAE.Project.progressMode ) return DuAEF.DuAE.Project.activeComp;
    //activate the viewer first to try to get the opened composition
    if( app.activeViewer != null)
    {
        if ( app.activeViewer.type == ViewerType.VIEWER_COMPOSITION ) app.activeViewer.setActive();
    }
    var comp = app.project.activeItem;
    if ( !comp ) return null;
    if ( !( comp instanceof CompItem ) ) return null;
    return comp;
}

/**
 * Retrieves an item by its Item ID
 * @return {Item|null} The item
 */
DuAEF.DuAE.Project.getItemById = function ( id ) {

    var it = new Iterator( app.project.items );
    while ( item = it.next() ) {
        if ( item.id == id ) return item;
    }
    return null;
}

/**
 * Generates a new unique name for a composition
 * @param {string} newName - The wanted new name
 * @param {CompItem} comp  - The comp
 * @param {boolean} [increment=true] - true to automatically increment the new name if it already ends with a digit
 * @return {string}	The unique name, with a new number at the end if needed.
 */
DuAEF.DuAE.Project.newUniqueCompName = function ( newName, increment ) {
    if ( typeof increment == 'undefined' ) increment = true;
    var compNames = [];
    var it = new Iterator( app.project.items );
    it.do( function ( comp ) {
        if ( comp instanceof CompItem ) compNames.push( comp.name );
    } );
    return DuAEF.DuJS.String.generateUnique( newName, compNames, increment );
}

/**
 * Makes sure all compositions in the project have unique names, renaming them if needed.
 */
DuAEF.DuAE.Project.setUniqueCompNames = function () {
    var comps = DuAEF.DuAE.Project.getComps();
    var it = new Iterator( app.project.items );
    it.do( function ( comp ) {
        //temporarily set another name to correctly generate a new unique name 
        var newName = comp.name;
        comp.name = '***Duik-temp-name-xxx***';
        comp.name = DuAEF.DuAE.Project.newUniqueCompName( newName );
    } );
}

/**
 * Updates the cache of the expressions used by Duik to speed up batch process of expressions in the whole project.<br />
 * It's automatically run when needed if it's not been updated in a long time (1 mn) or if it's empty
 */
DuAEF.DuAE.Project.updateExpressionCache = function () {

    if ( DuAEF.DuAE.Project.suspendCacheUpdates ) return;

    //clear cache
    DuAEF.DuAE.Project.expressionCache = [];

    for ( var i = 1, num = app.project.numItems; i <= num; i++ ) {
        var comp = app.project.item( i );
        if ( !( comp instanceof CompItem ) ) continue;

        for ( var l = 1, num = comp.numLayers; l <= num; l++ ) {
            DuAEF.DuAE.Property.addToExpressionCache( comp.layer( l ) );
        }
    }

    DuAEF.DuAE.Project.lastExpressionCacheUpdateTime = new Date().getTime();
}

//low-level undocumented method used to re-set expressions once they have been modified in the cache
DuAEF.DuAE.Project.updateExpressionsFromCache = function ( cache ) {
    for (var i = 0, num = cache.length; i < num; i++)
    {
        var pExp = cache[i];
        if (pExp.layer.locked) continue;
        if (!pExp.changed) continue;

        var prop = pExp.getProperty();
        prop.expression = pExp.expression;
    } 
}

/**
 * Reduces the project using the selected compositions, the same way the native command does it, but being able to keep comps used only by expressions. If there's no comp selected, will use all comps at the root of the project.
 * @param {boolean} [keepExpressionOnly=true] Set to false to ignore comps used only by expressions (same as the native command)
 */
DuAEF.DuAE.Project.reduceSelected = function ( keepExpressionOnly ) {
    var comps = [];
    for (var i = 0, num = app.project.selection.length; i < num; i++) {
        var item = app.project.selection[i];
        if (item instanceof CompItem) comps.push(item);
    }
    DuAEF.DuAE.Project.reduce( comps, keepExpressionOnly );
}

/**
 * Reduces the project, the same way the native command does it, but being able to keep comps used only by expressions.
 * @param {CompItem|CompItem[]} [comps] The name or the id of the comp(s) to keep. If omitted, it will use all comps at the root of the project (the ones not in a subfolder).
 * @param {boolean} [keepExpressionOnly=true] Set to false to ignore comps used only by expressions (same as the native command)
 */
DuAEF.DuAE.Project.reduce = function ( comps, keepExpressionOnly ) {
    keepExpressionOnly = def( keepExpressionOnly, true );
    comps = def( comps, DuAEF.DuAE.Project.getComps( true ) );
    if ( comps instanceof CompItem ) comps = [ comps ];
    if ( comps.length == 0 ) return;

    //consolidate footage
    app.project.consolidateFootage();

    //update cache before running
    DuAEF.DuAE.Project.updateExpressionCache();

    for ( i = app.project.numItems; i > 0; i-- ) {
        var item = app.project.item( i );
        //if it's one of the comp, ignore
        if ( DuAEF.DuJS.Array.indexOf( comps, item, DuAEF.DuAE.Item.compareItems ) >= 0 ) continue;
        //if AVItem
        if ( item instanceof CompItem || item instanceof FootageItem ) {
            var usedIn = DuAEF.DuAE.Item.usedIn( item, true, keepExpressionOnly );

            if ( usedIn.length == 0 ) {
                item.remove();
                continue;
            }

            var remove = true;

            for ( j = 0, num = usedIn.length; j < num; j++ ) {
                //if there's one of the comp to keep, do not remove
                if ( DuAEF.DuJS.Array.indexOf( comps, usedIn[ j ], DuAEF.DuAE.Item.compareItems ) >= 0 ) {
                    remove = false;
                    break;
                }
            }

            if ( remove ) item.remove();
        }
        //remove folder if  empty 
        else if ( item.numItems == 0 ) item.remove();
    }
}

/**
 * Collects all dependencies in a folder
 * @param {Folder} [destination] The folder where to save the files. The project files will be collected in a subfolder called "project name.aep.archive" or "project name.aep.zip". If not provided, will use the current folder.
 * @param {boolean} [overwrite=false] Wether to overwrite existing footage in the destination.
 * @param {boolean} [zip=false] Set to true to automatically zip the archive.
 * @param {boolean} [createProjectFolder=true] Wether to create a folder for this project or use the destination as is.
 */
DuAEF.DuAE.Project.collectFiles = function ( destination, overwrite, zip, createProjectFolder ) {
    var projectFile = app.project.file;

    var result = {};
    result.missingFootages = [];
    
    destination = def ( destination, projectFile.parent );
    overwrite = def (overwrite, false);
    zip = def (zip, false);
    createProjectFolder = def (createProjectFolder, true);

    //create folder for the project
    var projectName = DuAEF.DuJS.Fs.getBasename( projectFile.name );
    var projectFolderPath = destination.absoluteURI;
    if (createProjectFolder) {
        projectFolderPath += '/' + projectName + ".archive";
    }
    var projectFolder = new Folder( projectFolderPath );
	var footageFolder = new Folder( projectFolder.absoluteURI + "/(Footage)/" );
	projectFolder.create();
	footageFolder.create();

    //create report file
    var missingFootageString = "=== MISSING FOOTAGE ===\n\n";

    var currentFootageFolder = footageFolder;
    currentFootageFolder.id = -1;

	//for each item, copy and re-link
	for (var i = 1, num = app.project.numItems; i <= num; i++ ) {
        var item = app.project.item(i);

        //check if we're still in the right folder
        if (item.parentFolder.id != currentFootageFolder.id) {
            if (item.parentFolder == app.project.rootFolder )
            {
                currentFootageFolder = footageFolder;  
            }
            else
            {
                currentFootageFolder = currentFootageFolder.parent;
            }
            currentFootageFolder.id = item.parentFolder.id;
        }

        if ( item instanceof CompItem ) continue;
        if ( item instanceof FolderItem ) {
            currentFootageFolder = new Folder( currentFootageFolder.absoluteURI + "/" + item.name);
            currentFootageFolder.create();
            currentFootageFolder.id = item.id;
            continue;
        }

        //if no source file
        if (item.file == null) continue;
        //if missing source
        if (item.footageMissing) {
            missingFootageString += item.name + " @ " + item.file.fsName + "\n";
            result.missingFootages.push(item.file.fsName);
            continue;
        }

        //if this is not an image sequence
        if (!DuAEF.DuAE.Item.isImageSequence(item)) {
            var newPath = currentFootageFolder.absoluteURI + "/" + item.file.name;
            var newFile = new File( newPath );
            //copy
            if ( (newFile.exists && overwrite) || !newFile.exists) item.file.copy( newPath );
            //re-link
            item.replace(new File( newPath ));
        }
        else {
            //get files and create a folder
            var sequenceFolder = item.file.parent;
            var frameSequence = sequenceFolder.getFiles();
            var sequenceFolderTarget = new Folder(currentFootageFolder.absoluteURI + "/" + sequenceFolder.name + "/");
            sequenceFolderTarget.create();
            var newPath = sequenceFolderTarget.absoluteURI + "/" + item.file.name;
            var newFile = new File(newPath);

            //copy frames
            if ( (newFile.exists && overwrite) || !newFile.exists) {
                for (var j = 0, numFrames = frameSequence.length; j < numFrames; j++ ) {
                    var frame = frameSequence[j];
                    if ( frame instanceof Folder ) continue;
                    frame.copy( sequenceFolderTarget.absoluteURI + "/" + frame.name );
                }
            }
            
            //re-link
            item.replaceWithSequence(newFile, true);
        }

	}

	//sauvegarder le projet
    var newProjectFileName = DuAEF.DuJS.Fs.newUniqueFileName(app.project.file.name , projectFolder);
	app.project.save(new File(projectFolder.absoluteURI + "/" + newProjectFileName));

    //write report
    var reportFile = new File(projectFolder.absoluteURI + "/" + app.project.file.name + "_report.txt");
    var report = app.project.file.name + "\n\n";
    report += missingFootageString;
    DuAEF.DuJS.Fs.writeTextFile( reportFile, report );

    //ZIP
    if (zip) {
        app.project.close( CloseOptions.DO_NOT_SAVE_CHANGES );
        app.open( projectFile );
        var zipFile = DuAEF.Zip.compressFolderContent( projectFolder, projectName + ".zip", true );
    }
}

/**
 * Replaces text in Expressions
 * @param {string} oldString - The string to replace
 * @param {string} newString - The new string
 * @param {boolean} [caseSensitive=true] - Wether the search has to be case sensitive
 */
DuAEF.DuAE.Project.replaceInExpressions = function ( oldString, newString, caseSensitive ) {
    caseSensitive = def (caseSensitive, true);

    //update expression cache before searching
    DuAEF.DuAE.Project.updateExpressionCache();

    var re = new RegExp( DuAEF.DuJS.RegExp.escapeRegExp(oldString), caseSensitive ? 'g' : 'gi');

    //search and replace in the cache
    for (var i = 0, num = DuAEF.DuAE.Project.expressionCache.length; i < num; i++) {
        DuAEF.DuAE.Project.expressionCache[i].changed = re.test( DuAEF.DuAE.Project.expressionCache[i].expression );
        if (DuAEF.DuAE.Project.expressionCache[i].changed) DuAEF.DuAE.Project.expressionCache[i].expression = DuAEF.DuAE.Project.expressionCache[i].expression.replace( re, newString );
    }

    //update expressions from cache
    DuAEF.DuAE.Project.updateExpressionsFromCache( DuAEF.DuAE.Project.expressionCache )
}