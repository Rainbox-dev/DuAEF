/**
* Expression Library
* @namespace
* @memberof DuAEF.DuExpression
*/
DuAEF.DuExpression.Library = {};

/**
 * Adds some noise to a value.<br />
 * You may use seedRandom() before using this function as it will influence the generated noise.
 * A timeless noise can be achieved with <code>seedRandom(index,true)</code> for example.
 * @param {number|number[]} val The value to add noise to.
 * @param {float} quantity The quantity of noise. A percentage. 100 means the value can range from (val * 0) to (val * 2).
 * @example
 * seedRandom(index, true) // a timeless noise
 * addNoise(value, 50); // the property value will have noise between (value * 0.5) and (value * 1.5) which won't vary through time.
 * @example
 * seedRandom(index, false);
 * addNoise( value, 33); // the noise will change at each frame, varying between (value * .66) and (value * 1.33)
 */
DuAEF.DuExpression.Library.addNoise = ['',
	'function addNoise( val, quantity ) {',
	'  // a true random value to make sure all properties have a differente noise',
	'  // even with the same start value',
	'  var randomValue = random(0.9,1.1);',
	'  // generate a noise from the start value',
	'  // (which means properties with a similar value won\'t be to far away from each other)',
	'  var noiseValue = noise(valueAtTime(0) * randomValue);',
	'  noiseValue = noiseValue * (quantity / 100);',
	'  return val * ( noiseValue + 1 );',
	'}'
	].join('\n');

/**
 * Interpolates a value with a bezier curve.<br />
 * This method can replace <code>linear()</code> and <code>ease()</code> with a custom bézier interpolation.
 * @function
 * @param {number} t The value to interpolate
 * @param {number} tMin The minimum the value can take
 * @param {number} tMax The maximum the value can take
 * @param {number} value1 The minimum for the interpolated value
 * @param {number} value2 The maximum for the interpolated value
 * @return {number[]} bezierPoints an Array of 4 coordinates wihtin the 0.0 ... 1.0 range which describes the Bézier interpolation.<br />
 * [ outTangentX, outTangentY, inTangentX, inTangentY ]
 */
DuAEF.DuExpression.Library.bezier = ['',
	'function bezier(t, tMin, tMax, value1, value2, bezierPoints) {',
	'    if (arguments.length !== 6) return value;',
	'    var a = value2 - value1;',
	'    var b = tMax - tMin;',
	'    if (b == 0) return t;',
	'    var c = clamp((t - tMin) / b, 0, 1);',
	'    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4) bezierPoints = [0, 0, 1, 1];',
	'    return a * h(c, bezierPoints) + value1;',
	'',
	'    function h(f, g) {',
	'        var x = 3 * g[0];',
	'        var j = 3 * (g[2] - g[0]) - x;',
	'        var k = 1 - x - j;',
	'        var l = 3 * g[1];',
	'        var m = 3 * (g[3] - g[1]) - l;',
	'        var n = 1 - l - m;',
	'        var d = f;',
	'        for (var i = 0; i < 5; i++) {',
	'            var z = d * (x + d * (j + d * k)) - f;',
	'            if (Math.abs(z) < 1e-3) break;',
	'            d -= z / (x + d * (2 * j + 3 * k * d));',
	'        }',
	'        return d * (l + d * (m + d * n));',
	'    }',
	'}',
	''
	].join('\n');

/**
 * Checks the type of a pseudo-effect used by Duik.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * Pseudo-Effects used by Duik start with a hidden property which name is the same as the matchName of the effect itself (without the 'Pseudo/' part).
 * @function
 * @example
 * if ( checkEffect(thisLayer.effect(1), "DUIK parentConstraint2") ) { "This is the second version of the parent constraint by Duik" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {string} duikMatchName The matchName of a pseudo-effect used by Duik (without the 'Pseudo/' part)
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.DuExpression.Library.checkDuikEffect = ['',
	'function checkDuikEffect(fx, duikMatchName) {',
	'    if (fx.numProperties  < 3) return false;',
	'    if (!!$.engineName) {',
	'        if ( fx(2).name != duikMatchName ) return false;',
	'    }',
	'    else {',
	'        try { if (fx(2).name != duikMatchName) return false; }',
	'        catch (e) { return false; }',
	'    }',
	'    return true;',
	'}'
	].join('\n');

/**
 * Checks the type of an effect.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * It checks if the given effect has a specific property at a specific index.
 * @function
 * @example
 * if ( checkEffect(thisLayer.effect(1), 1, "Blur") ) { "The first effect is a blur!" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {int} propIndex The index of the property
 * @param {string} propName The expected name of the property. Be careful with the internationalization of After Effects...
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.DuExpression.Library.checkEffect = ['',
	'function checkEffect(fx, propIndex, propName) {',
	'    if (fx.numProperties  < propIndex) return false;',
	'    //Check when this is a javascript engine (without try/catch for better performance)',
	'    if (!!$.engineName) {',
	'        if ( fx(propIndex).name != propName ) return false;',
	'    }',
	'    //Check with the extendscript engine',
	'    else {',
	'        try { if (fx(propIndex).name != propName) return false; }',
	'        catch (e) { return false; }',
	'    }',
	'    return true;',
	'}'
	].join('\n');

/**
 * Removes the ancestors rotation from the rotation of a layer.
 * This is very useful to make a layer keep its orientation without being influenced by its parents.
 * @example
 * //in a rotation property, just include the function and use:
 * dishineritRotation();
 * //the layer will now keep its own orientation.
 * @example
 * //you can also combine the result with something else
 * var result = dishineritRotation();
 * result + wiggle(5,20);
 * @function
 * @param {Layer} [l=thisLayer] The layer
 * @return {float} The new rotation value, in degrees.
 */
DuAEF.DuExpression.Library.dishineritRotation = ['',
	'function dishineritRotation( l ) {',
	'    if (typeof l === "undefined") l = thisLayer;',
	'    var r = l.rotation.value;',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r -= l.rotation.value;',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Gets the "real" scale of a layer, resulting to its scale property, the scale of its parents, and it's location in Z-space if it's 3D.
 * @param {Layer} [l=thisLayer] The layer 
 * @param {number} [t=time] The time when to get the scale
 * @return {number} The scale ratio. This is not a percent, 1.0 is 100%.
 */
DuAEF.DuExpression.Library.getCompScale = ['',
	'function getCompScale( l, t ) {',
	'	if (typeof l === "undefined") l = thisLayer;',
	'	if (typeof t === "undefined") t = time;',
	'	',
	'	//get ratio ',
	'	var originalWidth = length( l.anchorPoint, [ l.width, 0 ] );',
	'	var anchorInComp = l.toComp( l.anchorPoint, t );',
	'	var widthInComp = l.toComp( [ l.width, 0 ], t );',
	'	var newWidth = length(anchorInComp, widthInComp);',
	'	return newWidth / originalWidth;',
	'}'
	].join('\n');

/**
 * Gets a layer from a layer property in an effect, without generating an error if "None" is selected with the Legacy expression engine.
 * @function
 * @param {Property} fx The effect
 * @param {int|string} ind The index or the name of the property
 * @return {Layer|null} The layer, or null if set to "None"
 */
DuAEF.DuExpression.Library.getEffectLayer = ['',
	'function getEffectLayer( fx, ind ) {',
	'	try { var l = fx( ind ); return l; }',
	'	catch ( e ) { return null; }	',
	'}'
	].join('\n');

/**
 * Gets the comp position (2D Projection in the comp) of a layer.
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [l=thisLayer] The layer
 * @return {number[]} The comp position
 */
DuAEF.DuExpression.Library.getLayerCompPos = ['',
	'function getLayerCompPos( t, l ) {',
	'    if (typeof l === "undefined") l = thisLayer;',
	'    if (typeof t === "undefined") t = time;',
	'    return l.toComp( l.anchorPoint, t );',
	'}'
	].join('\n');

/**
 * Gets the world position of a layer.
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [l=thisLayer] The layer
 * @return {number[]} The world position
 */
DuAEF.DuExpression.Library.getLayerWorldPos = ['',
	'function getLayerWorldPos(t, l) {',
	'	if (typeof l === "undefined") l = thisLayer;',
	'	if (typeof t === "undefined") t = time;',
	'	return l.toWorld(l.anchorPoint, t);',
	'}',
	''
	].join('\n');

/**
 * Gets the world instant speed of a layer.
 * @param {number} [t=time] The time when to get the velocity
 * @param {Layer} [l=thisLayer] The layer
 * @return {number} A positive number. The speed.
 * @requires getLayerWorldVelocity
 * @requires getLayerWorldPos
 */
DuAEF.DuExpression.Library.getLayerWorldSpeed = ['',
	'function getLayerWorldSpeed(t, l) {',
	'	return length(getWorldVelocity(t, l));',
	'}'
	].join('\n');

/**
 * Gets the world instant velocity of a layer.
 * @param {number} [t=time] The time when to get the velocity
 * @param {Layer} [l=thisLayer] The layer
 * @return {number[]} The velocity.
 * @requires getLayerWorldPos
 */
DuAEF.DuExpression.Library.getLayerWorldVelocity = ['',
	'function getLayerWorldVelocity(t, l) {',
	'	if (typeof t === "undefined") t = time;',
	'	return (getWorldPos(t, l) - getWorldPos(t - 0.01, l)) * 100;',
	'}'
	].join('\n');

/**
 * Gets the key immediately after the given time
 * @param {number} [t=time] Time at which to get the key
 * @return {Key|null} The key, or null if there's no key before.
 */
DuAEF.DuExpression.Library.getNextKey = ['',
	'function getNextKey(t) {',
	'    if (typeof t === "undefined") t = time;',
	'    if (numKeys == 0) return null;',
	'    var nKey = nearestKey(t);',
	'    if (nKey.time >= t) return nKey;',
	'    if (nKey.index < numKeys) return key(nKey.index + 1);',
	'    return null;',
	'  }',
	'  '
	].join('\n');

/**
 * Gets the world orientation of a (2D) layer.
 * @function
 * @param {Layer} l The layer to get the orientation from
 * @return {float} The orientation, in degrees.
 */
DuAEF.DuExpression.Library.getOrientation = ['',
	'function getOrientation( l ) {',
	'    var r = 0;',
	'    r += l.rotation.value;',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r += l.rotation.value;',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Gets the world orientation of a (2D) layer at a specific time.
 * @function
 * @param {Layer} l The layer to get the orientation from
 * @param {float} [t=time] The time at which to get the orientation
 * @return {float} The orientation, in degrees.
 */
DuAEF.DuExpression.Library.getOrientationAtTime = ['',
	'function getOrientationAtTime( l, t ) {',
	'    if (typeof t === "undefined" ) t = time;',
	'    var r = 0;',
	'    r += l.rotation.valueAtTime( t );',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r += l.rotation.valueAtTime( t );',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Gets the key immediately before the given time
 * @param {number} [t=time] Time at which to get the key
 * @return {Key|null} The key, or null if there's no key before.
 */
DuAEF.DuExpression.Library.getPrevKey = ['',
	'function getPrevKey(t) {',
	'    if (typeof t === "undefined") t = time;',
	'    if (numKeys == 0) return null;',
	'    var nKey = nearestKey(t);',
	'    if (nKey.time <= t) return nKey;',
	'    if (nKey.index > 1) return key(nKey.index - 1);',
	'    return null;',
	'  }'
	].join('\n');

/**
 * Gets the world speed of a property.
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [prop=thisProperty] The property
 * @return {number[]} The world speed
 * @requires getPropWorldVelocity
 * @requires getPropWorldValue
 * @requires getLayerWorldPos
 */
DuAEF.DuExpression.Library.getPropWorldSpeed = ['',
	'function getPropWorldSpeed(t, prop) {',
	'	return length(getPropWorldVelocity(t, prop));',
	'}'
	].join('\n');

/**
 * Gets the world coordinates of a property.
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [prop=thisProperty] The property
 * @return {number[]} The world coordinates
 * @requires getLayerWorldPos
 */
DuAEF.DuExpression.Library.getPropWorldValue = ['',
	'function getPropWorldValue(t, prop) {',
	'	if (typeof prop === "undefined") prop = thisProperty;',
	'	if (typeof t === "undefined") t = time;',
	'	if (isPosition(prop)) return getLayerWorldPos(t);',
	'	return thisLayer.toWorld(prop.valueAtTime(t), t);',
	'}'
	].join('\n');

/**
 * Gets the world velocity of a property.
 * @param {number} [t=time] Time from when to get the position
 * @param {Layer} [prop=thisProperty] The property
 * @return {number[]} The world velocity
 * @requires getPropWorldValue
 * @requires getLayerWorldPos
 */
DuAEF.DuExpression.Library.getPropWorldVelocity = ['',
	'function getPropWorldVelocity(t, prop) {',
	'	if (typeof t === "undefined") t = time;',
	'	return (getPropWorldValue(t, prop) - getPropWorldValue(t - 0.01, prop)) * 100;',
	'}'
	].join('\n');

/**
 * Checks if current time is after the time of the last key in the property
 * @return {boolean} true if time is > lastkey.time
 */
DuAEF.DuExpression.Library.isAfterLastKey = ['',
	'function isAfterLastKey() {',
	'	if (numKeys == 0) return false;',
	'	var nKey = nearestKey(time);',
	'	return nKey.time <= time && nKey.index == numKeys;',
	'}',
	''
	].join('\n');

/**
 * Checks if a property is a transform.position property.
 * @param {Property} [prop=thisProperty] The property
 * @return {boolean} true if the property is the transform.position property.
 */
DuAEF.DuExpression.Library.isPosition = ['',
	'function isPosition(prop) {',
	'	if (typeof prop === "undefined") prop = thisProperty;',
	'	if (!(thisProperty.value instanceof Array)) return false;',
	'	if (thisProperty.value.length > 3) return false;',
	'	//compare the value to world with the anchor point to world',
	'	var apWorld = thisLayer.toWorld(thisLayer.anchorPoint.valueAtTime(0), 0);',
	'	var posWorld = thisProperty.valueAtTime(0);',
	'	if (thisLayer.hasParent) posWorld = thisLayer.parent.toWorld(posWorld, 0);',
	'	var result = true;',
	'	for (var i = 0, num = thisProperty.value.length; i < num; i++) {',
	'		if (posWorld[i] != apWorld[i]) return false;',
	'	}',
	'	return true;',
	'}'
	].join('\n');

/**
 * Checks if the current property is animated at a given time.
 * @param {number} [t=time] The time
 * @param {number} [threshold=0.1] The speed under which the property is considered still.
 * @return {boolean} true if the property does not vary.
 */
DuAEF.DuExpression.Library.isStill = ['',
	'function isStill(t, threshold) {',
	'	if (typeof t === "undefined") t = time;',
	'	if (typeof threshold === "undefined") threshold = 0.1;',
	'	var d = valueAtTime(t) - valueAtTime(t + framesToTime(1));',
	'',
	'	if (d instanceof Array) {',
	'		for (var i = 0; i < d.length; i++) {',
	'			d[i] = Math.abs(d[i]);',
	'			if (d[i] >= threshold) {',
	'				return false;',
	'			}',
	'		}',
	'		return true;',
	'	} else {',
	'		d = Math.abs(d);',
	'		return d < threshold;',
	'	}',
	'}'
	].join('\n');

/**
 * Translates a point with a layer, as if it was parented to it.
 * @function
 * @param {Layer} l The layer to get the translation from.
 * @param {float[]} [point=[0,0]] The [X,Y] point to translate (using world coordinates).
 * @param {float} [startT=0] The start time of the translation
 * @param {float} [endT=timeToFrames()] The end time of the translation
 * @return {float[]} The coordinates of the translated point.
 */
DuAEF.DuExpression.Library.translatePointWithLayer = ['',
	'function translatePointWithLayer( l, point, startT, endT ) {',
	'    if (typeof startT === "undefined") startT = 0;',
	'    if (typeof endT === "undefined") endT = time;',
	'    try {',
	'        var pos = l.fromWorld( point, startT );',
	'    } catch ( e ) {',
	'        var pos = [ 0, 0 ];',
	'    }',
	'    var prevPos = l.toWorld( pos, startT );',
	'    var newPos = l.toWorld( pos, endT );',
	'    return newPos - prevPos;',
	'}'
	].join('\n');

