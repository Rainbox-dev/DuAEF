/**
* Expression Library
* @namespace
* @memberof DuAEF.DuExpression
*/
DuAEF.DuExpression.Library = {};

/**
 * Checks the type of a pseudo-effect used by Duik.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * Pseudo-Effects used by Duik start with a hidden property which name is the same as the matchName of the effect itself (without the 'Pseudo/' part).
 * @function
 * @example
 * if ( checkEffect(thisLayer.effect(1), "DUIK parentConstraint2") ) { "This is the second version of the parent constraint by Duik" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {string} duikMatchName The matchName of a pseudo-effect used by Duik (without the 'Pseudo/' part)
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.DuExpression.Library.checkDuikEffect = ['',
	'function checkDuikEffect(fx, duikMatchName) {',
	'    if (fx.numProperties  < 3) return false;',
	'    if (!!$.engineName) {',
	'        if ( fx(2).name != duikMatchName ) return false;',
	'    }',
	'    else {',
	'        try { if (fx(2).name != duikMatchName) return false; }',
	'        catch (e) { return false; }',
	'    }',
	'    return true;',
	'}'
	].join('\n');

/**
 * Checks the type of an effect.<br />
 * This is a workaround for the missing matchName in expressions.<br />
 * It checks if the given effect has a specific property at a specific index.
 * @function
 * @example
 * if ( checkEffect(thisLayer.effect(1), 1, "Blur") ) { "The first effect is a blur!" }
 * else { "Who knows what this is?" }
 * @param {Property} fx The effect to check
 * @param {int} propIndex The index of the property
 * @param {string} propName The expected name of the property. Be careful with the internationalization of After Effects...
 * @return {boolean} True when the property at propIndex is named propName
 */
DuAEF.DuExpression.Library.checkEffect = ['',
	'function checkEffect(fx, propIndex, propName) {',
	'    if (fx.numProperties  < propIndex) return false;',
	'    //Check when this is a javascript engine (without try/catch for better performance)',
	'    if (!!$.engineName) {',
	'        if ( fx(propIndex).name != propName ) return false;',
	'    }',
	'    //Check with the extendscript engine',
	'    else {',
	'        try { if (fx(propIndex).name != propName) return false; }',
	'        catch (e) { return false; }',
	'    }',
	'    return true;',
	'}'
	].join('\n');

/**
 * Removes the ancestors rotation from the rotation of a layer.
 * This is very useful to make a layer keep its orientation without being influenced by its parents.
 * @example
 * //in a rotation property, just include the function and use:
 * dishineritRotation();
 * //the layer will now keep its own orientation.
 * @example
 * //you can also combine the result with something else
 * var result = dishineritRotation();
 * result + wiggle(5,20);
 * @function
 * @param {Layer} [l=thisLayer] The layer
 * @return {float} The new rotation value, in degrees.
 */
DuAEF.DuExpression.Library.dishineritRotation = ['',
	'function dishineritRotation( l ) {',
	'    if (typeof l === "undefined") l = thisLayer;',
	'    var r = l.rotation.value;',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r -= l.rotation.value;',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Gets the world orientation of a (2D) layer.
 * @function
 * @param {Layer} l The layer to get the orientation from
 * @return {float} The orientation, in degrees.
 */
DuAEF.DuExpression.Library.getOrientation = ['',
	'function getOrientation( l ) {',
	'    var r = 0;',
	'    r += l.rotation.value;',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r += l.rotation.value;',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Gets the world orientation of a (2D) layer at a specific time.
 * @function
 * @param {Layer} l The layer to get the orientation from
 * @param {float} [t=time] The time at which to get the orientation
 * @return {float} The orientation, in degrees.
 */
DuAEF.DuExpression.Library.getOrientationAtTime = ['',
	'function getOrientationAtTime( l, t ) {',
	'    if (typeof t === "undefined" ) t = time;',
	'    var r = 0;',
	'    r += l.rotation.valueAtTime( t );',
	'    while ( l.hasParent ) {',
	'        l = l.parent;',
	'        r += l.rotation.valueAtTime( t );',
	'    }',
	'    return r;',
	'}'
	].join('\n');

/**
 * Translates a point with a layer, as if it was parented to it.
 * @function
 * @param {Layer} l The layer to get the translation from.
 * @param {float[]} [point=[0,0]] The [X,Y] point to translate (using world coordinates).
 * @param {float} [startT=0] The start time of the translation
 * @param {float} [endT=timeToFrames()] The end time of the translation
 * @return {float[]} The coordinates of the translated point.
 */
DuAEF.DuExpression.Library.translatePointWithLayer = ['',
	'function translatePointWithLayer( l, point, startT, endT ) {',
	'    if (typeof startT === "undefined") startT = 0;',
	'    if (typeof endT === "undefined") endT = time;',
	'    try {',
	'        var pos = l.fromWorld( point, startT );',
	'    } catch ( e ) {',
	'        var pos = [ 0, 0 ];',
	'    }',
	'    var prevPos = l.toWorld( pos, startT );',
	'    var newPos = l.toWorld( pos, endT );',
	'    return newPos - prevPos;',
	'}'
	].join('\n');

